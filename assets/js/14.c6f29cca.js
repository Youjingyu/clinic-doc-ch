(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{184:function(e,o,t){"use strict";t.r(o);var n=t(0),a=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"首次分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#首次分析","aria-hidden":"true"}},[e._v("#")]),e._v(" 首次分析")]),e._v(" "),t("p",[e._v("我们现在准备好分析其中一个示例应用了。第一个示例，我们使用 "),t("code",[e._v("slow-event-loop")]),e._v("。首先，我们通过在 "),t("code",[e._v("examples")]),e._v(" 目录中运行 "),t("code",[e._v("node slow-event-loop")]),e._v(" 来确认它已准备好并能工作。进程开始运行后，我们就可以在浏览器中访问 "),t("code",[e._v("http://localhost:3000/")]),e._v(" 进行检查。")]),e._v(" "),t("blockquote",[t("p",[e._v("We're now ready to profile one of the example applications. For the first example, we will use slow-event-loop. First, let's confirm that it is ready and working by running node slow-event-loop from inside the examples directory. Once the process seems to be running we can visit http://localhost:3000/ in a browser to check.")])]),e._v(" "),t("p",[e._v("我们可以在浏览器中看到一些基本输出，比如 "),t("code",[e._v("{}")]),e._v("。在命令行中按 Ctrl-C 关闭 "),t("code",[e._v("slow-event-loop")]),e._v(" 服务器。")]),e._v(" "),t("blockquote",[t("p",[e._v("We should see some basic output in the browser, like {}. Ctrl-C in the command line to close the slow-event-loop server.")])]),e._v(" "),t("p",[e._v("因为这是一个服务器，所以我们需要进行负载测试。对只处理一个请求的服务器进行分析不会为我们提供太多信息，也不知道它在处理许多请求时会如何执行。我们建议使用基准测试工具 "),t("code",[e._v("autocannon")]),e._v("。")]),e._v(" "),t("blockquote",[t("p",[e._v("This is a server, so we need to apply load. Profiling a server handling just one request doesn't give us much data or indication of how it performs when handling many requests. We recommend the benchmarking tool Autocannon.")])]),e._v(" "),t("p",[e._v("当执行 clinic 时，我们也会在示例应用目录中执行 "),t("code",[e._v("autocannon")]),e._v("，所以我们先使用以下命令全局安装它：")]),e._v(" "),t("blockquote",[t("p",[e._v("We will execute autocannon in the example application directories when we call the clinic executable, so let's install it globally, with the following command:")])]),e._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[e._v("npm")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v(" -g autocannon\n")])])]),t("p",[e._v("要对服务器进行负载测试，我们需要使用 Doctor 运行它，并在它开始侦听端口时立即调用 "),t("code",[e._v("autocannon")]),e._v("。只要服务器准备好处理请求并且 Doctor 也准备好收集数据，就会使用大量请求轰炸服务器。")]),e._v(" "),t("blockquote",[t("p",[e._v("To load-test the server, we want to run it with Doctor, and point autocannon at it as soon as it starts listening on a port. This will bombard the server with requests, as soon as it is ready to handle them and Doctor is ready to collect data.")])]),e._v(" "),t("p",[e._v("我们用下面这个命令完成所有操作，它会自动分配正确的端口：")]),e._v(" "),t("blockquote",[t("p",[e._v("Let's do all that with this single command, which automatically assigns the correct ports:")])]),e._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[e._v("clinic doctor --on-port "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'autocannon localhost:"),t("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$PORT")]),e._v("'")]),e._v(" -- node slow-event-loop\n")])])]),t("p",[e._v("我们拆分一下这个命令：")]),e._v(" "),t("blockquote",[t("p",[e._v("Let's break this command down:")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("clinic doctor")]),e._v(" 调用 Doctor 命令行工具。")])]),e._v(" "),t("blockquote",[t("p",[e._v("The clinic doctor portion invokes the Doctor command tool.")])]),e._v(" "),t("ul",[t("li",[e._v("--on-port 参数指定在服务开始监听端口后马上执行的脚本，即 "),t("code",[e._v("autocannon localhost:$PORT。")])])]),e._v(" "),t("blockquote",[t("p",[e._v("The --on-port flag will execute the supplied script as soon as the server starts listening on a port.")])]),e._v(" "),t("ul",[t("li",[e._v("脚本中的 "),t("code",[e._v("$PORT")]),e._v(" 变量是服务器开始侦听的第一个端口。")])]),e._v(" "),t("blockquote",[t("p",[e._v("The $PORT variable in that script is set to the first port that the server began listening on.")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("--")]),e._v(" 后面的命令用于启动我们要分析的服务，比如这里的 "),t("code",[e._v("node slow-event-loop")]),e._v("。")])]),e._v(" "),t("blockquote",[t("p",[e._v("Everything after the double-dash (--) is the command which starts the server that we want to profile, in this case node slow-event-loop.")])]),e._v(" "),t("p",[e._v("这行命令会运行三个可执行文件：父可执行文件 "),t("code",[e._v("clinic flame")]),e._v(", "),t("code",[e._v("--on-port")]),e._v(" 中的可执行文件 "),t("code",[e._v("autocannon")]),e._v("，以及可执行文件 "),t("code",[e._v("Node")]),e._v("。")]),e._v(" "),t("blockquote",[t("p",[e._v("This one command runs three executables: the clinic doctor parent executable, the autocannon executable in --on-port and the node executable.")])]),e._v(" "),t("p",[e._v("运行该命令后，"),t("code",[e._v("slow-event-loop")]),e._v(" 服务器将被 10 个并发连接的请求命中 10 秒（autocannon 的默认值）。然后将结果编译成单个 HTML 文件，该文件会浏览器中自动打开。")]),e._v(" "),t("blockquote",[t("p",[e._v("Upon running the command, the slow-event-loop server will be hit by requests from 10 concurrent connections for 10 seconds (as per autocannon defaults). then the results be compiled into a single HTML file that should automatically open in the browser.")])]),e._v(" "),t("p",[e._v("生成的 HTML 类似于下面这样：")]),e._v(" "),t("blockquote",[t("p",[e._v("The resulting HTML should look similar to the following:")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://clinicjs.org/static/d699a3eb16a8065de8aecbeb14f527d5/ace55/03.png",alt:""}})])])}],!1,null,null,null);o.default=a.exports}}]);